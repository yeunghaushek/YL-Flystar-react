/* // ========== Tail Pair Discovery & Trimming (Pre-merge) ==========

// 取得所有「首尾相同」路徑之尾端 pair（例如 ['文曲','財帛宮']）
function getCyclicTailPairs(routes) {
    const join2 = (a, b) => `${a}\x1f${b}`;
    const pairsSet = new Set();
 
    for (const r of routes) {
        if (!Array.isArray(r) || r.length < 2) continue;
        if (r[0] === r[r.length - 1]) {
            const tailStar = r[r.length - 2];
            const tailPalace = r[r.length - 1];
            pairsSet.add(join2(tailStar, tailPalace));
        }
    }
    return Array.from(pairsSet).map((s) => s.split("\x1f"));
}
 
// 計數 pair 在所有 routes 中出現次數（連續 bigram）
function countPairOccurrences(routes, [a, b]) {
    let count = 0;
    for (const r of routes) {
        if (!Array.isArray(r) || r.length < 2) continue;
        for (let i = 0; i < r.length - 1; i += 1) {
            if (r[i] === a && r[i + 1] === b) count += 1;
        }
    }
    return count;
}
 
// 從所有候選尾端 pair 中，挑選出現次數最多者（平手取第一個）
function chooseMostFrequentTailPair(routes, candidatePairs) {
    if (!candidatePairs.length) return null;
    let best = candidatePairs[0];
    let bestCnt = countPairOccurrences(routes, best);
    for (let i = 1; i < candidatePairs.length; i += 1) {
        const cnt = countPairOccurrences(routes, candidatePairs[i]);
        if (cnt > bestCnt) {
            best = candidatePairs[i];
            bestCnt = cnt;
        }
    }
    return best; // [star, palace]
}
 
// 以「唯一選出的尾端 pair」裁切所有路徑：遇到該 pair 即截斷（含兩元素）
function trimRoutesByChosenTailPair(routes) {
    const candidates = getCyclicTailPairs(routes);
    if (candidates.length === 0) return routes.map((r) => r.slice());
 
    const chosen = chooseMostFrequentTailPair(routes, candidates);
    if (!chosen) return routes.map((r) => r.slice());
 
    const [a, b] = chosen;
    return routes.map((route) => {
        if (!Array.isArray(route) || route.length < 2) return Array.isArray(route) ? route.slice() : route;
        for (let i = 0; i < route.length - 1; i += 1) {
            if (route[i] === a && route[i + 1] === b) {
                return route.slice(0, i + 2);
            }
        }
        return route.slice();
    });
}
 
// ========== Merge Engine (Rules 1–4, Safe) ==========
 
function mergeAllRoutesEnhancedSafe(inputRoutes, opts = {}) {
    const { logProgress = false, maxIterations = 2000, maxRoutes = 5000 } = opts;
    if (!Array.isArray(inputRoutes)) return { allRoutes: [], longestRoutes: [], longestLength: 0 };
 
    const joinKey = (r) => r.join("\x1f");
    const isCyclic = (r) => r.length > 0 && r[0] === r[r.length - 1];
 
    const originals = inputRoutes.map((r) => r.slice());
    const originalKeySet = new Set(originals.map(joinKey));
    const cyclicHeads = new Set(originals.filter(isCyclic).map((r) => r[0]));
    // 單一強尾（若外部已決議強尾，則使用；否則無強尾約束）
    const strongTailToken = opts && typeof opts.strongTail === 'string' ? opts.strongTail : null;
 
    // 規則1 + 規則4：尾首完整重疊；若合併結果中出現循環 head 且不在尾端，截斷於該 head
    function suffixPrefixMergesWithTrunc(a, b) {
        const results = [];
        const maxK = Math.min(a.length, b.length);
        for (let k = maxK; k >= 1; k -= 1) {
            let ok = true;
            for (let i = 0; i < k; i += 1) {
                if (a[a.length - k + i] !== b[i]) {
                    ok = false;
                    break;
                }
            }
            if (!ok) continue;
 
            let merged = [...a, ...b.slice(k)];
            // 依單一強尾截斷：一旦遇到強尾且其後仍有元素，立即截斷於該強尾
            const cutIdx = strongTailToken ? merged.findIndex((node, idx) => node === strongTailToken && idx !== merged.length - 1) : -1;
            if (cutIdx !== -1) merged = merged.slice(0, cutIdx + 1);

            // 追加限制：合併後若以「宮」結尾的項目數量 >= 5，則不允許該合併
            const palaceCount = (arr) => {
                let c = 0;
                for (const v of arr) {
                    if (typeof v === 'string' && v.endsWith('宮')) c += 1;
                }
                return c;
            };
            if (palaceCount(merged) >= 5) continue;
 
            results.push(merged);
        }
        return results;
    }
 
    const all = [];
    const seen = new Map();
    const originalMerged = new Set(); // 規則3：原始路徑只要參與過合併，就不輸出原始路徑
 
    function addRoute(r) {
        const k = joinKey(r);
        if (!seen.has(k)) {
            seen.set(k, r);
            all.push(r);
            return true;
        }
        return false;
    }
 
    // 初始化：先把原始 routes 放進池
    originals.forEach(addRoute);
 
    let grew = true;
    let iterations = 0;
 
    while (grew) {
        grew = false;
        iterations += 1;
        if (iterations > maxIterations) {
            if (logProgress) console.warn("[merge] Hit iteration cap:", iterations);
            break;
        }
        if (all.length > maxRoutes) {
            if (logProgress) console.warn("[merge] Hit route cap:", all.length);
            break;
        }
 
        const snapshot = all.slice();
        for (let i = 0; i < snapshot.length; i += 1) {
            for (let j = 0; j < snapshot.length; j += 1) {
                if (i === j) continue;
 
                const a = snapshot[i];
                const b = snapshot[j];
 
                // 規則2：不可把任何路徑接到「循環路徑的頭」之前 → 直接略過 b 為循環路徑
                if (isCyclic(b)) continue;
 
                const mergedList = suffixPrefixMergesWithTrunc(a, b);
                for (const merged of mergedList) {
                    // 安全：只接受會「變長」的合併，避免無效循環
                    if (merged.length <= Math.max(a.length, b.length)) continue;
 
                    const added = addRoute(merged);
                    if (added) {
                        grew = true;
 
                        const aKey = joinKey(a);
                        const bKey = joinKey(b);
                        if (originalKeySet.has(aKey)) originalMerged.add(aKey);
                        if (originalKeySet.has(bKey)) originalMerged.add(bKey);
 
                        if (all.length > maxRoutes) break;
                    }
                }
                if (all.length > maxRoutes) break;
            }
            if (all.length > maxRoutes) break;
        }
        if (logProgress) console.log(`[merge] iter=${iterations}, routes=${all.length}, grew=${grew}`);
    }
 
    // 規則3：參與過合併的原始路徑不輸出
    const filteredAll = all.filter((r) => {
        const k = joinKey(r);
        const isOriginal = originalKeySet.has(k);
        const isCyclicOriginal = isOriginal && r.length > 0 && r[0] === r[r.length - 1];
        // 保留循環原始路徑，就算參與過合併也不剔除
        return !(isOriginal && originalMerged.has(k) && !isCyclicOriginal);
    });
 
    let longestLength = 0;
    for (const r of filteredAll) longestLength = Math.max(longestLength, r.length);
    const longestRoutes = filteredAll.filter((r) => r.length === longestLength);
 
    return { allRoutes: filteredAll, longestRoutes, longestLength };
}
 
// ========== Post-processing: Remove Contained Subroutes ==========
 
// small 是否為 big 的「連續子序列」
function isContiguousSubarray(small, big) {
    if (!Array.isArray(small) || !Array.isArray(big)) return false;
    if (small.length === 0 || small.length > big.length) return false;
    outer: for (let i = 0; i <= big.length - small.length; i += 1) {
        for (let j = 0; j < small.length; j += 1) {
            if (big[i + j] !== small[j]) continue outer;
        }
        return true;
    }
    return false;
}
 
// 將被其它較長路徑完整包含的路徑移除
function removeContainedRoutes(routes) {
    const out = [];
    const isCyclicRoute = (r) => Array.isArray(r) && r.length > 0 && r[0] === r[r.length - 1];
    for (let i = 0; i < routes.length; i += 1) {
        const r = routes[i];
        // 保留循環路徑（head === tail），不視為可移除的「被包含子路徑」
        if (isCyclicRoute(r)) { out.push(r); continue; }
        let contained = false;
        for (let j = 0; j < routes.length; j += 1) {
            if (i === j) continue;
            const s = routes[j];
            if (s.length > r.length && isContiguousSubarray(r, s)) {
                contained = true;
                break;
            }
        }
        if (!contained) out.push(r);
    }
    return out;
}

// ========== Second-merge (extend by palace tail) ==========

// 星曜清單（保留：若後續需用到星曜判定可沿用）
const STARS_SET = new Set(["太陽","太陰","巨門","貪狼","天機","天同","文昌","文曲","武曲","廉貞"]);
function isStar(name) { return typeof name === 'string' && STARS_SET.has(name); }
function isPalace(name) { return typeof name === 'string' && name.endsWith('宮'); }

// 建立索引：在其他路徑中，凡出現『宮』且其後仍有元素，收集該『宮』後的後綴作為可延伸參考
function buildPalaceSuffixIndex(routes) {
    const map = new Map(); // key: palace -> Array<suffix[]>
    for (const r of routes) {
        if (!Array.isArray(r) || r.length < 2) continue;
        for (let i = 0; i < r.length - 1; i += 1) {
            const token = r[i];
            if (isPalace(token)) {
                const suffix = r.slice(i + 1);
                if (suffix.length === 0) continue;
                const key = token;
                if (!map.has(key)) map.set(key, []);
                map.get(key).push(suffix);
            }
        }
    }
    return map;
}

// 進一步延伸：若某路徑以『宮』結尾，且該『宮』在其他路徑中段出現過，則把其後綴接在尾端（遵守『宮』數量限制）
function extendRoutesByPalaceTail(routes, palaceLimit = 5, strongTailToken = null) {
    const index = buildPalaceSuffixIndex(routes);

    const joinKey = (r) => r.join("\x1f");
    const out = [];
    const seen = new Set();

    const palaceCount = (arr) => arr.reduce((c, v) => c + (isPalace(v) ? 1 : 0), 0);

    for (const r of routes) {
        if (!Array.isArray(r) || r.length < 1) {
            const k = joinKey(r);
            if (!seen.has(k)) { seen.add(k); out.push(r); }
            continue;
        }
        const tail = r[r.length - 1];
        const key = tail;

        let extendedAny = false;
        // 若尾端為強尾，禁止任何延伸
        if (strongTailToken && tail === strongTailToken) {
            // do nothing
        } else if (isPalace(tail) && index.has(key)) {
            for (const suffix of index.get(key)) {
                let merged = [...r, ...suffix];
                // 在延伸結果中，若遇到強尾且不在最後，立即在強尾處截斷
                if (strongTailToken) {
                    const cutIdx = merged.findIndex((token, idx) => token === strongTailToken && idx !== merged.length - 1);
                    if (cutIdx !== -1) merged = merged.slice(0, cutIdx + 1);
                }
                if (palaceCount(merged) >= palaceLimit) continue;
                const mk = joinKey(merged);
                if (!seen.has(mk)) { seen.add(mk); out.push(merged); extendedAny = true; }
            }
        }
        const rk = joinKey(r);
        if (!extendedAny && !seen.has(rk)) { seen.add(rk); out.push(r); }
    }

    return out;
}
 
// ========== Sorting: anchor tail similarity → tail bigram popularity → length → tail n-gram ==========
 
// 取得路徑的尾端 pair（最後兩個節點）；長度不足 2 則回傳 null
function tailPairOf(route) {
    if (!Array.isArray(route) || route.length < 2) return null;
    return [route[route.length - 2], route[route.length - 1]];
}
 
// 取得路徑結尾長度為 n 的片段（suffix）；不足 n 回傳 null
function tailSlice(route, n) {
    if (!Array.isArray(route) || route.length < n) return null;
    return route.slice(route.length - n);
}
 
// 計算某個連續片段（n-gram）在所有 routes 中的出現次數
function countNgramOccurrences(routes, seq) {
    if (!Array.isArray(seq) || seq.length === 0) return 0;
    let count = 0;
    for (const r of routes) {
        if (!Array.isArray(r) || r.length < seq.length) continue;
        outer: for (let i = 0; i <= r.length - seq.length; i += 1) {
            for (let j = 0; j < seq.length; j += 1) {
                if (r[i + j] !== seq[j]) continue outer;
            }
            count += 1;
        }
    }
    return count;
}

// 比較兩條路徑的「由尾端往前的 n-gram 熱度」（定義於此，供初排和最終排序共用）
function compareByTailNgramPopularity(a, b, routesPool) {
    const maxN = Math.min(a.length, b.length);
    for (let n = maxN; n >= 2; n -= 1) {
        const aSuffix = tailSlice(a, n);
        const bSuffix = tailSlice(b, n);
        if (!aSuffix || !bSuffix) continue;
        const aCnt = countNgramOccurrences(routesPool, aSuffix);
        const bCnt = countNgramOccurrences(routesPool, bSuffix);
        if (aCnt !== bCnt) return bCnt - aCnt;
    }
    return 0;
}

// 計算兩條路徑的共同尾段長度（Longest Common Suffix）
function commonTailLen(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return 0;
    let i = 1;
    const max = Math.min(a.length, b.length);
    while (i <= max && a[a.length - i] === b[b.length - i]) i += 1;
    return i - 1;
}

function stripTailIfPresent(arr, tail) {
    if (tail.length === 0) return arr;           // 移除空尾端 => 無變化
    if (tail.length > arr.length) return arr;    // 尾端比主陣列長 => 不可能匹配
  
    const offset = arr.length - tail.length;
    for (let i = 0; i < tail.length; i++) {
      if (arr[offset + i] !== tail[i]) return arr; // 不匹配 => 回傳原陣列
    }
    return arr.slice(0, offset+1); // 匹配 => 回傳去除尾端後的陣列
  }
 
// 依：1) 與錨點共同尾段長度(套用閾值) 2) 尾端 pair 熱度 3) 長度 4) 尾端 n-gram 熱度 5) 生年忌 6) 字典序
function sortRoutesByTailPopularityThenLength(allRoutes, routesPool, opts = {}) {
    if (!Array.isArray(allRoutes) || allRoutes.length === 0) return [];

    const { minCommonTailMatchLen = 2 } = opts; // 單一元素相同(=1)視為不匹配

    // 初排（不含錨點相似度）：尾端 pair 熱度 → 長度 → n-gram → 生年忌 → 字典序，用於選錨點
    const prelim = [...allRoutes].sort((a, b) => {
        const pair = (r) => tailPairOf(r) || ["",""];
        const join = (r) => r.join("\x1f");
        const cnt = (r) => countPairOccurrences(routesPool, pair(r));
        const cA = cnt(a), cB = cnt(b);
        if (cA !== cB) return cB - cA;
        if (a.length !== b.length) return b.length - a.length;
        const ng = compareByTailNgramPopularity(a, b, routesPool);
        if (ng !== 0) return ng;
        const hasSeed = (r) => Array.isArray(r) && r.includes("生年忌");
        const aSeed = hasSeed(a), bSeed = hasSeed(b);
        if (aSeed !== bSeed) return aSeed ? -1 : 1;
        return join(a).localeCompare(join(b));
    });
    const anchor = prelim[0];

    // 建立尾端 pair 熱度與最熱門 pair（供生年忌 tie-break）
    let maxTailCount = -1;
    const tailCountCache = new Map();
    const getTailKey = (route) => {
        const pair = tailPairOf(route);
        return pair ? `${pair[0]}\x1f${pair[1]}` : "";
    };
    const getTailCount = (route) => {
        const pair = tailPairOf(route);
        if (!pair) return -1;
        const key = `${pair[0]}\x1f${pair[1]}`;
        if (!tailCountCache.has(key)) tailCountCache.set(key, countPairOccurrences(routesPool, pair));
        return tailCountCache.get(key);
    };
    for (const r of allRoutes) {
        const pair = tailPairOf(r);
        if (!pair) continue;
        const key = `${pair[0]}\x1f${pair[1]}`;
        if (!tailCountCache.has(key)) tailCountCache.set(key, countPairOccurrences(routesPool, pair));
        const c = tailCountCache.get(key);
        if (c > maxTailCount) maxTailCount = c;
    }

    const includesSeed = (route) => Array.isArray(route) && route.includes("生年忌");

    return [...allRoutes].sort((a, b) => {
        // 1) 與錨點共同尾段長度（大→小），但若僅 1 個元素相同則視為 0（不匹配）
        let aSim = commonTailLen(a, anchor);
        let bSim = commonTailLen(b, anchor);
        if (aSim < minCommonTailMatchLen) aSim = 0;
        if (bSim < minCommonTailMatchLen) bSim = 0;
        if (aSim !== bSim) return bSim - aSim;

        // 2) 尾端 pair 熱度（routesPool 基底）
        const aTailCount = getTailCount(a);
        const bTailCount = getTailCount(b);
        if (aTailCount !== bTailCount) return bTailCount - aTailCount;

        // 3) 長度（長→短）
        if (a.length !== b.length) return b.length - a.length;

        // 4) 尾端 n-gram 熱度（routesPool 基底）
        const ngramCmp = compareByTailNgramPopularity(a, b, routesPool);
        if (ngramCmp !== 0) return ngramCmp;

        // 5) 若同尾端、同長度，且該尾端為最熱門，優先包含「生年忌」
        const aTail = getTailKey(a);
        const bTail = getTailKey(b);
        if (aTail && aTail === bTail) {
            const aCount = getTailCount(a);
            if (aCount === maxTailCount) {
                const aHas = includesSeed(a);
                const bHas = includesSeed(b);
                if (aHas !== bHas) return aHas ? -1 : 1;
            }
        }

        // 6) 字典序穩定 tie-break
        return a.join("\x1f").localeCompare(b.join("\x1f"));
    });
}
 
// ========== Pipeline (Trim → Merge → Filter → Second-merge → Sort) ==========
 
export function trimThenMergeWithMostFrequentTailThenFilterThenSort(routes, originalRoutes, opts) {
    const trimmed = trimRoutesByChosenTailPair(routes);

    // 強尾挑選：
    // 1) 找出所有 head===tail 的候選尾（只取尾部宮名）
    // 2) 若候選數量 >= 2，計算每個候選 pre-star + tail 的相鄰 bigram 次數，選最大者為唯一強尾
    //    若某循環路徑長度 < 2，則該候選無前星，視為 0 分
    const candidateTails = [];
    for (const r of routes) {
        if (Array.isArray(r) && r.length > 0 && r[0] === r[r.length - 1]) {
            const tail = r[r.length - 1];
            const prevStar = r.length >= 2 ? r[r.length - 2] : null;
            candidateTails.push([prevStar, tail]);
        }
    }

    let strongTail = null;
    if (candidateTails.length === 1) {
        strongTail = candidateTails[0][1];
    } else if (candidateTails.length >= 2) {
        let bestTail = null;
        let bestScore = -1;
        for (const [prev, tail] of candidateTails) {
            let score = 0;
            if (prev != null) score = countPairOccurrences(routes, [prev, tail]);
            if (score > bestScore) { bestScore = score; bestTail = tail; }
        }
        strongTail = bestTail;
    }

    const merged = mergeAllRoutesEnhancedSafe(trimmed, { ...opts, strongTail });

    // Post-filter
    let filteredRoutes = removeContainedRoutes(merged.allRoutes);

    // Second-merge: extend by palace tail (only)
    filteredRoutes = extendRoutesByPalaceTail(filteredRoutes, 5, strongTail);

    // Run filter again to drop any now-contained routes
    filteredRoutes = removeContainedRoutes(filteredRoutes);

    // Remove the already existed extendRoutes first. It will be added at the last.
    const { pairs, extendRoutes } = findOppositePalaceRoutes(originalRoutes);
    for (let i = 0; i < extendRoutes.length; i++) {
        for (let j = 0; j < filteredRoutes.length; j++) {
            filteredRoutes[j] = stripTailIfPresent(filteredRoutes[j], extendRoutes[i]);
        }
    }

    // Sort（優先：與錨點共同尾段長度(>=2) → 尾端 pair 熱度 → 長度 → 尾端 n-gram 熱度）
    const sortedRoutes = sortRoutesByTailPopularityThenLength(filteredRoutes, filteredRoutes, { minCommonTailMatchLen: 1 });
 
    let longestLength = 0;
    for (const r of sortedRoutes) longestLength = Math.max(longestLength, r.length);
    const longestRoutes = sortedRoutes.filter((r) => r.length === longestLength);
 
    return {
        allRoutes: sortedRoutes,
        longestRoutes,
        longestLength,
    };
}
 
// ========== Opposite Palace Checker ==========
// Given original routes (length 13 expected), pair indices 0..11 by opposite palace (i <-> (i+6)%12).
// For each route i in 0..11: find its "next palace" (prefer item[2] if it ends with '宮',
// otherwise the first palace token after head). If that palace equals the head of its opposite route
// (and the opposite route's head is not '生年忌'), collect this route (slice to first 3) as extendRoutes.
// Also return distinct opposite palace pairs (head_i, head_opp) with palace names only, skipping heads '生年忌'.
export function findOppositePalaceRoutes(originalRoutes) {
    if (!Array.isArray(originalRoutes)) return { pairs: [], extendRoutes: [] };
    const total = originalRoutes.length;
    if (total < 12) return { pairs: [], extendRoutes: [] };

    const isPalaceLocal = (name) => typeof name === 'string' && name.endsWith('宮');

    const oppositeIndex = (i) => (i + 6) % 12; // only within first 12 routes
    const extendRoutes = [];

    // Build distinct opposite head pairs (palace names only), skipping '生年忌'
    const pairSet = new Set();
    for (let i = 0; i < Math.min(12, total); i += 1) {
        const j = oppositeIndex(i);
        if (!(i < j)) continue; // only record each pair once
        const r1 = originalRoutes[i];
        const r2 = originalRoutes[j];
        if (!Array.isArray(r1) || !Array.isArray(r2) || r1.length === 0 || r2.length === 0) continue;
        const h1 = r1[0];
        const h2 = r2[0];
        if (h1 === '生年忌' || h2 === '生年忌') continue;
        if (!isPalaceLocal(h1) || !isPalaceLocal(h2)) continue;
        pairSet.add(`${h1}\x1f${h2}`);
    }
    const pairs = Array.from(pairSet).map(k => k.split('\x1f'));

    // Find routes that can be extended based on opposite head matching their next palace
    for (let i = 0; i < Math.min(12, total); i += 1) {
        const route = originalRoutes[i];
        if (!Array.isArray(route) || route.length === 0) continue;

        // find next palace: prefer index 2 if valid; else search from index 1
        let nextPalace = null;
        if (route.length > 2 && isPalaceLocal(route[2])) {
            nextPalace = route[2];
        } else {
            for (let k = 1; k < route.length; k += 1) {
                if (isPalaceLocal(route[k])) { nextPalace = route[k]; break; }
            }
        }
        if (!nextPalace) continue;

        const j = oppositeIndex(i);
        const oppRoute = originalRoutes[j];
        if (!Array.isArray(oppRoute) || oppRoute.length === 0) continue;

        const oppHead = oppRoute[0];
        if (oppHead === '生年忌') continue; // do not consider this as a head

        if (oppHead === nextPalace) {
            extendRoutes.push(route.slice(0, 3));
        }
    }

    return { pairs, extendRoutes };
} */

 
/*
Rules & Flow
 
Flow:
1) Trim discovery:
   - 掃描所有「首尾相同」的路徑，取其最後兩個元素作為候選尾端 pair（例如 ['文曲','財帛宮']）。
   - 若有多個候選尾端 pair，統計其在所有輸入路徑中的出現次數（相鄰 bigram），選出出現次數最多者。
   - 對所有路徑進行裁切：一旦遇到選定的尾端 pair，截斷到該 pair（含兩元素）。

1.5) Strong tail（單一強尾）的決策與約束：
   - 候選蒐集：掃描所有 head===tail 的循環路徑，記錄每個候選尾部宮名 tail 及其前一顆星曜 prevStar（若長度 < 2 則 prevStar 視為 null）。
   - 單一化決策：
     - 若候選僅 1 個 → 直接採用其 tail 作為 strongTail。
     - 若候選 ≥ 2 → 計算每個 [prevStar, tail] 在原始 routes 中的相鄰 bigram 出現次數，取分數最高者之 tail 為唯一 strongTail。
   - 硬尾約束（在後續所有步驟生效）：
     - 一旦在非末端遇到 strongTail，立即於該處截斷（確保 strongTail 為最終尾端）。
     - 若當前路徑尾端本身為 strongTail，禁止再做任何延伸。

2) Merge (Rules 1–4, safe):
   - 規則1：僅在「a 的尾部」等於「b 的首部」的完整重疊下合併 → merged = a + b[overlapLen:]。
     追加限制：
     - 合併後若路徑中以「宮」結尾的項目數量 >= 5，則不允許該合併（避免產生過長的『宮』鏈）。
     - 依強尾約束：合併結果中若在非末端出現 strongTail，立即截斷於 strongTail（保持尾端穩定）。
   - 規則2：若某路徑為循環（head === tail），禁止把任何東西接到它的頭之前（不可當 b 的 target）。
   - 規則3：凡原始路徑只要參與過合併（成為某次合併的 a 或 b），則不輸出該原始路徑本體。
   - 規則4：若合併結果中出現「循環路徑的 head」且不在尾端，立即截斷於該 head，保證尾端穩定。
   - 安全措施：只接受會「變長」的合併，並設置迭代與總路徑數上限，避免組合爆炸或長時間停滯。
 
3) Post-filter:
   - 新規則：移除任何是其他更長路徑「連續子序列」的路徑（例如 ['疾厄宮','文曲','財帛宮'] 被包含於較長路徑時剔除）。

2.5) Second-merge (simplified):
   - 若某條路徑以『宮』結尾，且該『宮』在另一條路徑的中段出現過，則可把該路徑中該『宮』之後的後綴接在此路徑尾端（遵守『宮』數量限制）。
   - 依強尾約束：
     - 若尾端為 strongTail，禁止任何延伸（直接保留原路徑）。
     - 延伸後結果若在非末端遇到 strongTail，立即於該處截斷。
   - 之後再執行一次 Post-filter 以移除新產生的子路徑。

2.75) Remove the already existed extendRoutes first. It will be added at the last.
 
4) Sorting (final output order):
   - 先選錨點（用尾端 pair 熱度→長度→n-gram→生年忌→字典序預排取第一條）。
   - 最終排序鍵（依序）：
     1) 與錨點共同尾段長度（越長越前；若僅 1 個元素相同則視為不匹配）
     2) 尾端 pair 熱度（以過濾後集合計數）
     3) 路徑長度（長→短）
     4) 尾端 n-gram 熱度（從較長 n 到 2，以過濾後集合計數）
     5) 生年忌 tie-break（在最熱門尾端下）
     6) 字典序穩定收尾
 
Outputs:
- allRoutes：套用上述規則後的所有可能結果（已去除子路徑）。
- longestRoutes：最長長度的所有結果。
- longestLength：最長長度數值。
*/
